{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"STAC-geoparquet","text":"<p>Convert STAC items between JSON, GeoParquet, pgstac, and Delta Lake.</p>"},{"location":"#purpose","title":"Purpose","text":"<p>The STAC spec defines a JSON-based schema. But it can be hard to manage and search through many millions of STAC items in JSON format. For one, JSON is very large on disk. And you need to parse the entire JSON data into memory to extract just a small piece of information, say the <code>datetime</code> and one <code>asset</code> of an Item.</p> <p>GeoParquet can be a good complement to JSON for many bulk-access and analytic use cases. While STAC Items are commonly distributed as individual JSON files on object storage or through a STAC API, STAC GeoParquet allows users to access a large number of STAC items in bulk without making repeated HTTP requests.</p> <p>For analytic questions like \"find the items in the Sentinel-2 collection in June 2024 over New York City with cloud cover of less than 20%\" it can be much, much faster to find the relevant data from a GeoParquet source than from JSON, because GeoParquet needs to load only the relevant columns for that query, not the full data.</p> <p>See the STAC-GeoParquet specification for details on the exact schema of the written Parquet files.</p>"},{"location":"#usage","title":"Usage","text":"<p>Use <code>stac_geoparquet.to_arrow.stac_items_to_arrow</code> and <code>stac_geoparquet.from_arrow.stac_table_to_items</code> to convert between STAC items and Arrow tables. Arrow Tables of STAC items can be written to parquet with <code>stac_geoparquet.to_parquet.to_parquet</code>.</p> <p>Note that <code>stac_geoparquet</code> lifts the keys in the item <code>properties</code> up to the top level of the DataFrame, similar to <code>geopandas.GeoDataFrame.from_features</code>.</p> <pre><code>&gt;&gt;&gt; import requests\n&gt;&gt;&gt; import stac_geoparquet.arrow\n&gt;&gt;&gt; import pyarrow.parquet\n&gt;&gt;&gt; import pyarrow as pa\n\n&gt;&gt;&gt; items = requests.get(\n...     \"https://planetarycomputer.microsoft.com/api/stac/v1/collections/sentinel-2-l2a/items\"\n... ).json()[\"features\"]\n&gt;&gt;&gt; table = pa.Table.from_batches(stac_geoparquet.arrow.parse_stac_items_to_arrow(items))\n&gt;&gt;&gt; stac_geoparquet.arrow.to_parquet(table, \"items.parquet\")\n&gt;&gt;&gt; table2 = pyarrow.parquet.read_table(\"items.parquet\")\n&gt;&gt;&gt; items2 = list(stac_geoparquet.arrow.stac_table_to_items(table2))\n</code></pre>"},{"location":"#pgstac-integration","title":"pgstac integration","text":"<p><code>stac_geoparquet.pgstac_reader</code> has some helpers for working with items coming from a <code>pgstac.items</code> table. It takes care of</p> <ul> <li>Rehydrating the dehydrated items</li> <li>Partitioning by time</li> <li>Injecting dynamic links and assets from a STAC API</li> </ul>"},{"location":"usage/","title":"Usage","text":""},{"location":"api/arrow/","title":"<code>stac_geoparquet.arrow</code>","text":"<p>Arrow-based format conversions.</p>"},{"location":"api/arrow/#stac_geoparquet.arrow","title":"stac_geoparquet.arrow","text":""},{"location":"api/arrow/#stac_geoparquet.arrow.DEFAULT_JSON_CHUNK_SIZE","title":"DEFAULT_JSON_CHUNK_SIZE  <code>module-attribute</code>","text":"<pre><code>DEFAULT_JSON_CHUNK_SIZE = 65536\n</code></pre> <p>The default chunk size to use for reading JSON into memory.</p>"},{"location":"api/arrow/#stac_geoparquet.arrow.DEFAULT_PARQUET_SCHEMA_VERSION","title":"DEFAULT_PARQUET_SCHEMA_VERSION  <code>module-attribute</code>","text":"<pre><code>DEFAULT_PARQUET_SCHEMA_VERSION: SUPPORTED_PARQUET_SCHEMA_VERSIONS = '1.1.0'\n</code></pre> <p>The default GeoParquet schema version written to file.</p>"},{"location":"api/arrow/#stac_geoparquet.arrow.SUPPORTED_PARQUET_SCHEMA_VERSIONS","title":"SUPPORTED_PARQUET_SCHEMA_VERSIONS  <code>module-attribute</code>","text":"<pre><code>SUPPORTED_PARQUET_SCHEMA_VERSIONS = Literal['1.0.0', '1.1.0']\n</code></pre> <p>A Literal type with the supported GeoParquet schema versions.</p>"},{"location":"api/arrow/#stac_geoparquet.arrow.parse_stac_items_to_arrow","title":"parse_stac_items_to_arrow","text":"<pre><code>parse_stac_items_to_arrow(\n    items: Iterable[dict[str, Any]],\n    *,\n    chunk_size: int = 8192,\n    schema: Schema | InferredSchema | None = None\n) -&gt; Iterable[RecordBatch]\n</code></pre> <p>Parse a collection of STAC Items to an iterable of <code>pyarrow.RecordBatch</code>.</p> <p>The objects under <code>properties</code> are moved up to the top-level of the Table, similar to <code>geopandas.GeoDataFrame.from_features</code>.</p> <p>Parameters:</p> <ul> <li> <code>items</code>               (<code>Iterable[dict[str, Any]]</code>)           \u2013            <p>the STAC Items to convert</p> </li> <li> <code>chunk_size</code>               (<code>int</code>, default:                   <code>8192</code> )           \u2013            <p>The chunk size to use for Arrow record batches. This only takes effect if <code>schema</code> is not None. When <code>schema</code> is None, the input will be parsed into a single contiguous record batch. Defaults to 8192.</p> </li> <li> <code>schema</code>               (<code>Schema | InferredSchema | None</code>, default:                   <code>None</code> )           \u2013            <p>The schema of the input data. If provided, can improve memory use; otherwise all items need to be parsed into a single array for schema inference. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Iterable[RecordBatch]</code>           \u2013            <p>an iterable of pyarrow RecordBatches with the STAC-GeoParquet representation of items.</p> </li> </ul>"},{"location":"api/arrow/#stac_geoparquet.arrow.parse_stac_ndjson_to_arrow","title":"parse_stac_ndjson_to_arrow","text":"<pre><code>parse_stac_ndjson_to_arrow(\n    path: str | Path | Iterable[str | Path],\n    *,\n    chunk_size: int = DEFAULT_JSON_CHUNK_SIZE,\n    schema: Schema | None = None,\n    limit: int | None = None\n) -&gt; Iterator[RecordBatch]\n</code></pre> <p>Convert one or more newline-delimited JSON STAC files to a generator of Arrow RecordBatches.</p> <p>Each RecordBatch in the returned iterator is guaranteed to have an identical schema, and can be used to write to one or more Parquet files.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str | Path | Iterable[str | Path]</code>)           \u2013            <p>One or more paths to files with STAC items.</p> </li> <li> <code>chunk_size</code>               (<code>int</code>, default:                   <code>DEFAULT_JSON_CHUNK_SIZE</code> )           \u2013            <p>The chunk size. Defaults to 65536.</p> </li> <li> <code>schema</code>               (<code>Schema | None</code>, default:                   <code>None</code> )           \u2013            <p>The schema to represent the input STAC data. Defaults to None, in which case the schema will first be inferred via a full pass over the input data. In this case, there will be two full passes over the input data: one to infer a common schema across all data and another to read the data.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>limit</code>               (<code>int | None</code>)           \u2013            <p>The maximum number of JSON Items to use for schema inference</p> </li> </ul> <p>Yields:</p> <ul> <li> <code>RecordBatch</code>           \u2013            <p>Arrow RecordBatch with a single chunk of Item data.</p> </li> </ul>"},{"location":"api/arrow/#stac_geoparquet.arrow.parse_stac_ndjson_to_delta_lake","title":"parse_stac_ndjson_to_delta_lake","text":"<pre><code>parse_stac_ndjson_to_delta_lake(\n    input_path: str | Path | Iterable[str | Path],\n    table_or_uri: str | Path | DeltaTable,\n    *,\n    chunk_size: int = DEFAULT_JSON_CHUNK_SIZE,\n    schema: Schema | None = None,\n    limit: int | None = None,\n    schema_version: SUPPORTED_PARQUET_SCHEMA_VERSIONS = DEFAULT_PARQUET_SCHEMA_VERSION,\n    **kwargs: Any\n) -&gt; None\n</code></pre> <p>Convert one or more newline-delimited JSON STAC files to Delta Lake</p> <p>Parameters:</p> <ul> <li> <code>input_path</code>               (<code>str | Path | Iterable[str | Path]</code>)           \u2013            <p>One or more paths to files with STAC items.</p> </li> <li> <code>table_or_uri</code>               (<code>str | Path | DeltaTable</code>)           \u2013            <p>A path to the output Delta Lake table</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>chunk_size</code>               (<code>int</code>, default:                   <code>DEFAULT_JSON_CHUNK_SIZE</code> )           \u2013            <p>The chunk size to use for reading JSON into memory. Defaults to 65536.</p> </li> <li> <code>schema</code>               (<code>Schema | None</code>, default:                   <code>None</code> )           \u2013            <p>The schema to represent the input STAC data. Defaults to None, in which case the schema will first be inferred via a full pass over the input data. In this case, there will be two full passes over the input data: one to infer a common schema across all data and another to read the data and iteratively convert to GeoParquet.</p> </li> <li> <code>limit</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The maximum number of JSON records to convert.</p> </li> <li> <code>schema_version</code>               (<code>SUPPORTED_PARQUET_SCHEMA_VERSIONS</code>, default:                   <code>DEFAULT_PARQUET_SCHEMA_VERSION</code> )           \u2013            <p>GeoParquet specification version; if not provided will default to latest supported version.</p> </li> </ul>"},{"location":"api/arrow/#stac_geoparquet.arrow.parse_stac_ndjson_to_parquet","title":"parse_stac_ndjson_to_parquet","text":"<pre><code>parse_stac_ndjson_to_parquet(\n    input_path: str | Path | Iterable[str | Path],\n    output_path: str | Path,\n    *,\n    chunk_size: int = DEFAULT_JSON_CHUNK_SIZE,\n    schema: Schema | InferredSchema | None = None,\n    limit: int | None = None,\n    schema_version: SUPPORTED_PARQUET_SCHEMA_VERSIONS = DEFAULT_PARQUET_SCHEMA_VERSION,\n    **kwargs: Any\n) -&gt; None\n</code></pre> <p>Convert one or more newline-delimited JSON STAC files to GeoParquet</p> <p>Parameters:</p> <ul> <li> <code>input_path</code>               (<code>str | Path | Iterable[str | Path]</code>)           \u2013            <p>One or more paths to files with STAC items.</p> </li> <li> <code>output_path</code>               (<code>str | Path</code>)           \u2013            <p>A path to the output Parquet file.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>chunk_size</code>               (<code>int</code>)           \u2013            <p>The chunk size. Defaults to 65536.</p> </li> <li> <code>schema</code>               (<code>Schema | InferredSchema | None</code>)           \u2013            <p>The schema to represent the input STAC data. Defaults to None, in which case the schema will first be inferred via a full pass over the input data. In this case, there will be two full passes over the input data: one to infer a common schema across all data and another to read the data and iteratively convert to GeoParquet.</p> </li> <li> <code>limit</code>               (<code>int | None</code>)           \u2013            <p>The maximum number of JSON records to convert.</p> </li> <li> <code>schema_version</code>               (<code>SUPPORTED_PARQUET_SCHEMA_VERSIONS</code>)           \u2013            <p>GeoParquet specification version; if not provided will default to latest supported version.</p> </li> </ul>"},{"location":"api/arrow/#stac_geoparquet.arrow.stac_table_to_items","title":"stac_table_to_items","text":"<pre><code>stac_table_to_items(table: Table) -&gt; Iterable[dict]\n</code></pre> <p>Convert a STAC Table to a generator of STAC Item <code>dict</code>s</p>"},{"location":"api/arrow/#stac_geoparquet.arrow.stac_table_to_ndjson","title":"stac_table_to_ndjson","text":"<pre><code>stac_table_to_ndjson(table: Table, dest: str | Path | PathLike[bytes]) -&gt; None\n</code></pre> <p>Write a STAC Table to a newline-delimited JSON file.</p>"},{"location":"api/arrow/#stac_geoparquet.arrow.to_parquet","title":"to_parquet","text":"<pre><code>to_parquet(\n    table: Table,\n    where: Any,\n    *,\n    schema_version: SUPPORTED_PARQUET_SCHEMA_VERSIONS = DEFAULT_PARQUET_SCHEMA_VERSION,\n    **kwargs: Any\n) -&gt; None\n</code></pre> <p>Write an Arrow table with STAC data to GeoParquet</p> <p>This writes metadata compliant with either GeoParquet 1.0 or 1.1.</p> <p>Parameters:</p> <ul> <li> <code>table</code>               (<code>Table</code>)           \u2013            <p>The table to write to Parquet</p> </li> <li> <code>where</code>               (<code>Any</code>)           \u2013            <p>The destination for saving.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>schema_version</code>               (<code>SUPPORTED_PARQUET_SCHEMA_VERSIONS</code>)           \u2013            <p>GeoParquet specification version; if not provided will default to latest supported version.</p> </li> </ul>"},{"location":"api/legacy/","title":"Direct GeoPandas conversion (Legacy)","text":"<p>The API listed here was the initial non-Arrow-based STAC-GeoParquet implementation, converting between JSON and GeoPandas directly. For large collections of STAC items, using the new Arrow-based functionality (under the <code>stac_geoparquet.arrow</code> namespace) will be more performant.</p>"},{"location":"api/legacy/#stac_geoparquet.to_geodataframe","title":"stac_geoparquet.to_geodataframe","text":"<pre><code>to_geodataframe(\n    items: Sequence[dict[str, Any]],\n    add_self_link: bool = False,\n    dtype_backend: DTYPE_BACKEND | None = None,\n    datetime_precision: str = \"ns\",\n) -&gt; GeoDataFrame\n</code></pre> <p>Convert a sequence of STAC items to a <code>geopandas.GeoDataFrame</code>.</p> <p>The objects under <code>properties</code> are moved up to the top-level of the DataFrame, similar to <code>geopandas.GeoDataFrame.from_features</code>.</p> <p>Parameters:</p> <ul> <li> <code>items</code>               (<code>Sequence[dict[str, Any]]</code>)           \u2013            <p>A sequence of STAC items.</p> </li> <li> <code>add_self_link</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>bool, default False Add the absolute link (if available) to the source STAC Item as a separate column named \"self_link\"</p> </li> <li> <code>dtype_backend</code>               (<code>DTYPE_BACKEND | None</code>, default:                   <code>None</code> )           \u2013            <p><code>{'pyarrow', 'numpy_nullable'}</code>, optional The dtype backend to use for storing arrays.</p> <p>By default, this will use 'numpy_nullable' and emit a FutureWarning that the default will change to 'pyarrow' in the next release.</p> <p>Set to 'numpy_nullable' to silence the warning and accept the old behavior.</p> <p>Set to 'pyarrow' to silence the warning and accept the new behavior.</p> <p>There are some difference in the output as well: with <code>dtype_backend=\"pyarrow\"</code>, struct-like fields will explicitly contain null values for fields that appear in only some of the records. For example, given an <code>assets</code> like::</p> <pre><code>{\n    \"a\": {\n        \"href\": \"a.tif\",\n    },\n    \"b\": {\n        \"href\": \"b.tif\",\n        \"title\": \"B\",\n    }\n}\n</code></pre> <p>The <code>assets</code> field of the output for the first row with <code>dtype_backend=\"numpy_nullable\"</code> will be a Python dictionary with just <code>{\"href\": \"a.tiff\"}</code>.</p> <p>With <code>dtype_backend=\"pyarrow\"</code>, this will be a pyarrow struct with fields <code>{\"href\": \"a.tif\", \"title\", None}</code>. pyarrow will infer that the struct field <code>asset.title</code> is nullable.</p> </li> <li> <code>datetime_precision</code>               (<code>str</code>, default:                   <code>'ns'</code> )           \u2013            <p>str, default \"ns\" The precision to use for the datetime columns. For example, \"us\" is microsecond and \"ns\" is nanosecond.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>GeoDataFrame</code>           \u2013            <p>The converted GeoDataFrame.</p> </li> </ul>"},{"location":"api/legacy/#stac_geoparquet.to_item_collection","title":"stac_geoparquet.to_item_collection","text":"<pre><code>to_item_collection(df: GeoDataFrame) -&gt; ItemCollection\n</code></pre> <p>Convert a GeoDataFrame of STAC items to a <code>pystac.ItemCollection</code>.</p> <p>Parameters:</p> <ul> <li> <code>df</code>               (<code>GeoDataFrame</code>)           \u2013            <p>A GeoDataFrame with a schema similar to that exported by stac-geoparquet.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ItemCollection</code>           \u2013            <p>The converted <code>ItemCollection</code>. There will be one record / feature per row in the in the GeoDataFrame.</p> </li> </ul>"},{"location":"api/legacy/#stac_geoparquet.to_dict","title":"stac_geoparquet.to_dict","text":"<pre><code>to_dict(record: dict) -&gt; dict\n</code></pre> <p>Create a dictionary representing a STAC item from a row of the GeoDataFrame.</p> <p>Parameters:</p> <ul> <li> <code>record</code>               (<code>dict</code>)           \u2013            <p>dict</p> </li> </ul>"},{"location":"spec/stac-geoparquet-spec/","title":"STAC GeoParquet Specification","text":""},{"location":"spec/stac-geoparquet-spec/#overview","title":"Overview","text":"<p>This document specifies how to map a set of STAC Items into GeoParquet. It is directly inspired by the STAC GeoParquet library, but aims to provide guidance for anyone putting STAC data into GeoParquet.</p>"},{"location":"spec/stac-geoparquet-spec/#use-cases","title":"Use cases","text":"<ul> <li>Provide a STAC GeoParquet that mirrors a static Collection as a way to query the whole dataset instead of reading every specific GeoJSON file.</li> <li>As an output format for STAC API responses that is more efficient than paging through thousands of pages of GeoJSON.</li> <li>Provide efficient access to specific fields of a STAC item, thanks to Parquet's columnar format.</li> </ul>"},{"location":"spec/stac-geoparquet-spec/#guidelines","title":"Guidelines","text":"<p>Each row in the Parquet Dataset represents a single STAC item. Most all the fields in a STAC Item should be mapped to a column in GeoParquet. We embrace Parquet structures where possible, mapping from JSON into nested structures. We do pull the properties to the top level, so that it is easier to query and use them. The names of most of the fields should be the same in STAC and in GeoParquet.</p> Field GeoParquet Type Required Details type String Optional This is just needed for GeoJSON, so it is optional and not recommended to include in GeoParquet stac_extensions List of Strings Required This column is required, but can be empty if no STAC extensions were used id String Required Required, should be unique within each collection geometry Binary (WKB) Required For GeoParquet 1.0 this must be well-known Binary bbox Struct of Floats Required Can be a 4 or 6 value struct, depending on dimension of the data. It must conform to the \"Bounding Box Columns\" definition of GeoParquet 1.1. links List of Link structs Required See Link Struct for more info assets An Assets struct Required See Asset Struct for more info collection String Optional The ID of the collection this Item is a part of. See notes below on 'Collection' and 'Collection JSON' in the Parquet metadata property columns varies - Each property should use the relevant Parquet type, and be pulled out of the properties object to be a top-level Parquet field <ul> <li>Must be valid GeoParquet, with proper metadata. Ideally the geometry types are defined and as narrow as possible.</li> <li>Strongly recommend to only have one GeoParquet per STAC 'Collection'. Not doing this will lead to an expanded GeoParquet schema (the union of all the schemas of the collection) with lots of empty data</li> <li>Any field in 'properties' of the STAC item should be moved up to be a top-level field in the GeoParquet.</li> <li>STAC GeoParquet does not support properties that are named such that they collide with a top-level key.</li> <li>datetime columns should be stored as a native timestamp, not as a string</li> <li>The Collection JSON should be included in the Parquet metadata. See Collection JSON below.</li> <li>Any other properties that would be stored as GeoJSON in a STAC JSON Item (e.g. <code>proj:geometry</code>) should be stored as a binary column with WKB encoding. This simplifies the handling of collections with multiple geometry types.</li> </ul>"},{"location":"spec/stac-geoparquet-spec/#link-struct","title":"Link Struct","text":"<p>The GeoParquet dataset can contain zero or more Link Structs. Each Link Struct has 2 required fields and 2 optional ones:</p> Field Name Type Description href string REQUIRED. The actual link in the format of an URL. Relative and absolute links are both allowed. rel string REQUIRED. Relationship between the current document and the linked document. See chapter \"Relation types\" for more information. type string Media type of the referenced entity. title string A human readable title to be used in rendered displays of the link. <p>See Link Object for more.</p>"},{"location":"spec/stac-geoparquet-spec/#asset-struct","title":"Asset Struct","text":"<p>The GeoParquet dataset can contain zero or more Asset Structs. Each Asset Struct can have the following fields:</p> Field Name Type Description href string REQUIRED. URI to the asset object. Relative and absolute URI are both allowed. title string The displayed title for clients and users. description string A description of the Asset providing additional details, such as how it was processed or created. CommonMark 0.29 syntax MAY be used for rich text representation. type string Media type of the asset. See the common media types in the best practice doc for commonly used asset types. roles [string] The semantic roles of the asset, similar to the use of <code>rel</code> in links. <p>Each struct has each full asset key and object as a sub-struct, it's a direct mapping from the JSON to Parquet</p> <p>To take advantage of Parquet's columnar nature and compression, the assets should be uniform so they can be represented by a simple schema, which in turn means every item should probably come from the same STAC collection.</p> <p>See Asset Object for more.</p>"},{"location":"spec/stac-geoparquet-spec/#including-a-stac-collection-json-in-a-stac-geoparquet-collection","title":"Including a STAC Collection JSON in a STAC Geoparquet Collection","text":"<p>To make a stac-geoparquet file a fully self-contained representation, you can include the Collection JSON in the Parquet metadata. If present in the Parquet file metadata, the key must be <code>stac:collection</code> and the value must be a JSON string with the Collection JSON.</p>"},{"location":"spec/stac-geoparquet-spec/#referencing-a-stac-geoparquet-collections-in-a-stac-collection-json","title":"Referencing a STAC Geoparquet Collections in a STAC Collection JSON","text":"<p>A common use case of stac-geoparquet is to create a mirror of a STAC collection. To refer to this mirror in the original collection, use an Asset Object at the collection level of the STAC JSON that includes the <code>application/vnd.apache.parquet</code> Media type and <code>collection-mirror</code> Role type to describe the function of the Geoparquet STAC Collection Asset.</p> <p>For example:</p> Field Name Type Value href string s3://example/uri/to/file.parquet title string An example STAC GeoParquet. description string Example description. type string <code>application/vnd.apache.parquet</code> roles [string] [collection-mirror]* <p>*Note the IANA has not approved the new Media type <code>application/vnd.apache.parquet</code> yet, it's been submitted for approval.</p> <p>The description should ideally include details about the spatial partitioning method.</p>"},{"location":"spec/stac-geoparquet-spec/#mapping-to-other-geospatial-data-formats","title":"Mapping to other geospatial data formats","text":"<p>The principles here can likely be used to map into other geospatial data formats (GeoPackage, FlatGeobuf, etc), but we embrace Parquet's nested 'structs' for some of the mappings, so other formats will need to do something different. The obvious thing to do is to dump JSON into those fields, but that's outside the scope of this document, and we recommend creating a general document for that.</p>"}]}